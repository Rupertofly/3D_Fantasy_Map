<html>
<head>
  <meta charset="UTF-8">

  <!-- PLEASE NO CHANGES BELOW THIS LINE (UNTIL I SAY SO) -->
  <script language="javascript" type="text/javascript" src="lib/d3.js"></script>
  <script language="javascript" type="text/javascript" src="lib/priority-queue.js"></script>
  <script language="javascript" type="text/javascript" src="lib/terrain.js"></script>
  <script language="javascript" type="text/javascript" src="lib/delaunay.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="lib/three.min.js"></script>
  <script src="lib/dat.gui.js"></script>





  <!-- OK, YOU CAN MAKE CHANGES BELOW THIS LINE AGAIN -->

  <!-- this line removes any default padding and style. you might only need one of these values set. -->
  <style> body {padding: 0; margin: 0;} </style>
</head>

<body>
  <script type="x-shader/x-vertex" id="vertexshader">

		// switch on high precision floats
		#ifdef GL_ES
		precision highp float;
		#endif
		#if NUM_DIR_LIGHTS > 0
				struct DirectionalLight {
						vec3 direction;
						vec3 color;
						int shadow;
						float shadowBias;
						float shadowRadius;
						vec2 shadowMapSize;
				 };
				 uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
		#endif
		uniform float amplitude;
		attribute float displacement;
		varying vec3 vNormal;
    varying vec3 newPosition;
		varying vec2 vUV;
		varying vec3 vecPos;
		varying vec3 col;
		varying vec3 vecNormal;
		void main() {
			vecPos = (modelMatrix * vec4(position, 1.0 )).xyz;
			vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;
			vUV = uv;
  		vNormal = normalMatrix * normal;
			col = position;
			// multiply our displacement by the
			// amplitude. The amp will get animated
			// so we'll have animated displacement
			newPosition = position;
			gl_Position = projectionMatrix *
						  modelViewMatrix *
						  vec4(newPosition,1.0);
		}
	</script>

	<script type="x-shader/x-fragment" id="fragmentshader">
		#ifdef GL_ES
		precision highp float;
		#endif
		#if NUM_DIR_LIGHTS > 0
		    struct DirectionalLight {
		        vec3 direction;
		        vec3 color;
		        int shadow;
		        float shadowBias;
		        float shadowRadius;
		        vec2 shadowMapSize;
		     };
		     uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
		#endif
		varying vec3 col;
		// same name and type as VS
		varying vec3 vNormal;
		varying vec2 vUV;
		varying vec3 vecNormal;
		void main() {
			vec3 rar = directionalLights[0].direction;
			// ensure it's normalized
			vec3 light = normalize(vec3(0.0,100.0,0.0));
			vec3 nubac = normalize(vecNormal);

// calculate the dot product of
// the light to the vertex normal
			float dProd = clamp(dot(nubac, rar),0.0,1.0);
			vec3 newnubac = vec3(-1.0*nubac.x, -1.0*nubac.y,-1.0*nubac.z);
			// feed into our frag colour
			vec3 color = vec3(-0.5*col.x, -0.5*col.y, -col.z);
			vec3 colour = color*dProd*1.0;
			gl_FragColor = vec4(clamp(colour,0.0,1.0)+0.1, 1.0);

		}

	</script>


</body>
  <script language="javascript" type="text/javascript" src="lib/p5.js"></script>
  <script language="javascript" type="text/javascript" src="Threes_testing.js"></script>
</html>
